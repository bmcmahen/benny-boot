#!/usr/bin/env node

/**
 * Modules
 */

var resolve = require('component-resolver');
var build = require('component-builder');
var autoprefix = require('builder-autoprefixer');
var program = require('commander');
var Q = require('q');
var fs = require('fs');
var minify = require('minify');
var write = fs.writeFileSync;
var path = require('path');
var mkdirp = require('mkdirp');
var myth = require('myth');
var npath = require('path');
var clc = require('cli-color');

var error = clc.red.bgWhite;
var warn = clc.yellow.bold.underline;
var notice = clc.blue;
var success = clc.black.bgWhite;


var buildTree;
var BUILD_PATH = npath.join(__dirname, '/../public/client/');
var DESTINATION = npath.join(__dirname, '/../public');

/**
 * Options
 */

program
  .option('-m, --module [name]', 'create a clientside component')
  .option('-w, --watch', 'watch client directory for changes and build automagically')
  .option('-p, --production', 'build resources for production environment')
  .option('-b, --build', 'build our clientside components and resources')
  .parse(process.argv);


if (program.module) {
  if (!program.name) throw Error('Name required');
  mkdirp(npath.join(__dirname, '/../client/'+ program.name));
}

/**
 * Enable watching of a path
 */

if (program.watch) {
  console.log(warn('Watching for changes...'));
  var watcher = require('component-watcher')(process.cwd());
  Q.when(resolveDeps()).then(function(){
    watcher.on('resolve', resolveDeps);
    watcher.on('scripts', buildScripts);
    watcher.on('styles', buildStyles);
  });
}



/**
 * Build Scripts
 * @param  {Tree} tree 
 */

function buildScripts(){
  var deferred = Q.defer();
  build.scripts(buildTree)
    .use('scripts', build.plugins.js())
    .use('json', build.plugins.json())
    .use('templates', build.plugins.string())
    .end(function(err, string){
      if (err) throw err;
      if (!string) return;
      string = build.scripts.require + string;
      string += 'require("./client/boot")\n';
      if (program.production) string = minify.js(string);
      mkdirp(BUILD_PATH, function(){
        console.log(notice('Built scripts.'));
        write(BUILD_PATH + 'boot.js', string);
        deferred.resolve();
      });
    });
    return deferred.promise;
}

/**
 * Build Styles
 * @param  {Tree} tree 
 */

function buildStyles(){
  var deferred = Q.defer();
  build.styles(buildTree)
    .use('styles', autoprefix())
    .end(function(err, string){
      if (err) throw err;
      string = myth(string);
      if (program.production) string = minify.css(string);
      mkdirp(BUILD_PATH, function(){
        write(BUILD_PATH + 'boot.css', string);  
        console.log(notice('Built stylesheets.'));
        deferred.resolve();     
      });
    });
  return deferred.promise;
}

/**
 * Build Files
 * @param  {Tree} tree 
 */

function buildFiles(){
  var deferred = Q.defer();
  build.files(buildTree, { destination: DESTINATION })
    .use('images', build.plugins.copy())
    .use('fonts', build.plugins.copy())
    .use('files', build.plugins.copy())
    .end(deferred.resolve);
  return deferred.promise;
}


function resolveDeps(exit){

  var deferred = Q.defer();

  var options = {
    install: true,
    out: process.cwd() + '/client/components'
  };

  console.log('Resolving dependencies...');
  
  resolve(process.cwd(), options, function(err, tree){
    if (err) throw err;
    console.log(notice('Dependencies resolved.'));
    buildTree = tree;
    Q.all([buildScripts(), buildStyles(), buildFiles()])
      .then(function(){
        console.log(success('Finished building. Wohoo.'));
        deferred.resolve();
        if (exit) process.exit();
      });
  });

  return deferred.promise;
}

/**
 * Build a particular component
 */

if (program.build){
  resolveDeps(true);
}

